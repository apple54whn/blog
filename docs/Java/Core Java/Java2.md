# 2 类与对象

## 2.1 什么是类、对象

* **类**：是一组相关**属性**和**行为**的集合
  * **属性**：就是该事物的**状态信息**。
  * **行为**：就是该事物**能够做什么**
* **对象**：是**一类事物**的**具体体现**
* **类与对象的关系**
  * 类是对一类事物的描述，是抽象的
  * 对象是一类事物的实例，是具体的
  * ==**类是对象的模板，对象是类的实体**==

* **类的定义格式**

  ```java
  public class ClassName {
      //成员变量，对应事物的属性，描述事物的状态信息
      //构造方法：创建事物对象
      //成员方法，对应事物的行为，描述事物能做什么
  }
  ```

* **对象的使用**

  * 创建对象：`类名 对象名 = new 类名();`
  * 使用对象访问类中的成员：`对象名.成员变量； 对象名.成员方法()`

* 匿名对象（了解）：没有对象名的对象。若一个对象只需要使用唯一的一次，就可以使用匿名对象。

  * 创建匿名对象直接调用方法，没有变量名；匿名对象可以作为方法的参数和返回值。

* ==**成员变量的默认值**：整数类型—0；浮点类型—0.0；字符类型—‘\u0000’；布尔类型—false；引用类型—null==

* **两个对象使用同一方法**的内存图

  对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息 只保存一份，节约内存空间。 

  ![](images\02-两个对象使用同一个方法的内存图.png)

* **两个引用指向同一对象**的内存图

  ![](images\03-两个引用指向同一个对象的内存图.png)

* **引用类型作为参数传递到方法中，传递的是地址值**

  ![](images\04-使用对象类型作为方法的参数.png)

* **使用引用类型作为方法的返回值，返回值就是对象的地址值**

  ![](images\05-使用对象类型作为方法的返回值.png)

## 2.2 成员变量与局部变量

变量根据**定义位置**的不同，我们给变量起了不同的名字，成员变量与局部变量区别如下：

* ==在类中定义的**位置不同**（重点）== 
  * 成员变量：**类中，方法外** 
  * 局部变量：**方法中或者方法声明上(形式参数)** 
* ==**作用范围不一样**（重点）== 
  * 成员变量：**类中** 
  * 局部变量：**方法中**
* ==**初始化值的不同**（重点）== 
  * 成员变量：**有默认值** 
  * 局部变量：**没有默认值。必须先定义，赋值，最后使用** 
* ==在**内存中的位置不同**（了解）== 
  * 成员变量：**堆**内存 
  * 局部变量：**栈**内存 
* ==**生命周期不同** （了解）== 
  * 成员变量：**随着对象**的创建而存在，随着对象被垃圾回收而消失
  * 局部变量：**随着方法**的调用而存在，随着方法的调用完毕而消失 



## 2.3 面向对象

* 面向对象特点：**封装、继承、多态**

### 2.3.1 封装

* 原则：将**属性隐藏**起来，若需要访问某个属性，**提供公共方法**向外暴露出该对象的功能

* 封装的步骤：
  1. 使用 **private** 关键字来修饰成员变量
  2. 对需要访问的成员变量，提供对应的一对 **getXxx（isXxx）** 方法 、 **setXxx** 方法

* **private关键字**含义
  * private是一个权限修饰符，代表**最小权限**。 
  * 可以修饰**成员变量**和**成员方法**。 
  * 被private修饰后的成员变量和成员方法，只在**本类中才能访问**。 

* **this关键字**含义（可用于访问本类的成员变量、成员方法、另一个构造方法。**只能有一个，且在第一句**）
  * this代表**所在类的当前对象的引用**（地址值），即**对象自己的引用**。
    * 记住 ：==方法**被哪个对象调用**，方法中的this**就代表那个对象**。即谁在调用，this就代表谁。== 

* **构造方法**(**创建对象时**构造方法用来**初始化该对象**，给对象的**成员变量赋初始值**)
  - 构造方法名与类名相同
  - 构造方法名前面没有返回值类型
  - 构造方法不能return一个具体返回值，可以有return;但是没意义
  - 类中没有定义构造方法，**系统会自动创建一个默认的无参构造方法**，一旦定义构造方法，系统就不提供了
  - 构造方法也可以重载

* 标准代码—**JavaBean**

  * JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是**具体的和公共的**，并且具有**无参数的构造方法**，提供用来操作成员变量的 **set 和 get** 方法。

* **构造方法与成员方法的区别**

  * **命名**不同
    * 构造方法：类名一致
    * 成员方法：自定义
  * **返回值类型**不同
    * 构造方法：无返回值类型
    * 成员方法：void或者确定的数据类型
  * **调用**不同
    ​	构造方法：new 关键字调用
    ​	成员方法：对象.成员方法名调用

  * **作用**不同
    * 构造方法：创建对象
    * 成员方法：执行某具体功能



### 2.3.2 static

如果一个成员使用了static关键字，那么这个成员不再属于自己，而是**属于所在类**，**多个对象共享这个成员**。

- 修饰**类的成员**(成员变量，成员方法，代码块等)

  - ==**类第一次被加载（或第一次创建对象或访问静态数据成员）**==时执行，可以通**类名.静态成员**直接调用

- **静态代码块（静态初始化块）**——用来**一次性对静态成员变量赋值**

  - **构造代码块（初始化块）**：**构造类的对象**时执行对非静态成员变量的赋值

- **静态使用的注意事项**

  1. 静态方法只能访问静态成员，==**静态不能直接访问非静态**==。（非静态既可以访问静态，又可以访问非静态）
  2. 静态方法中不可以使用 this或者super关键字，因为其代表**对象，静态不能使用对象调用
  3. 主函数是静态的

- 静态内存图

  ![](images\03-静态的内存图.png)










### 2.3.3 继承

* 由来
  * 继承主要**解决**的问题是：**共性抽取**。
  * 继承描述的是事物之间的所属关系，这种关系是： **is-a 的关系**。父类更通用，子类更具体。

* **定义**：**继承**就是**子类继承父类的属性和行为**，使得子类对象具有与父类相同的属性、相同的行为。

  * 子类可以**直接访问**父类中的**非私有的属性和行为**。

* 好处：
  * **提高代码的复用性**。 
  * 类与类之间产生了关系，是**多态的前提**。 

* **super关键字**（用于子类访问父类的成员变量、成员方法、构造方法）
  * 子类**每个构造方法中均有默认的super()**调用父类的空参构造。手动调用父类构造会覆盖默认的super()
  * 在构造方法中super只能有**一个**，在子类构造方法里的**第一个语句**，所以不能和this同时出现
  * 子父类出现同名成员，在**子类中需要访问父类中非私有成员**时，需要**使用 super 关键字，修饰父类成员**

* ==继承后**成员变量**：若重名则**就近**使用，使用super区分父类变量。**编译看左边，运行看左边**==

  * 子父类中出现了**同名**的**成员变量**，则创建子类对象时，访问有两种方式：
    * **直接通过子类对象访问**成员变量：**=左边对象是谁**，就优先用谁，没有则向**上**找
    * **间接通过成员方法访问**成员变量：该**方法属于谁**，就优先用谁，没有则向**上**找

* ==继承后**构造方法**：无影响，但是子类构造方法默认调用父类构造方法==

  - **子类构造必须先调用父类构造方法进行初始化**，不写则默认**赠送super()**，写则用写的**指定super**调用
  - 构造方法的名字是与类名一致的。所以子类是**无法继承**父类**构造方法**的

* ==继承后**成员方法**：重名，子类重写父类方法。**编译看左边，运行看右边**==

  * 在父子类的继承关系中，创建子类对象，访问成员方法的规则：
    * **创建的对象(new)是谁，就优先用谁**，没有则向**上**找

* ==**方法重写 (Override)**==：子类中出现与父类**一模一样的方法**时，会出现**覆盖**效果，也称为重写或者复写。声明不变，**重新实现**。注意事项如下：==（一般特点：**越大方**、**越好**(异常继承中)、**越分工明确**）==

  * 必须要保证**权限大于等于父类权限**。 

  * **返回值引用类型（小于等于父类范围，如Object、String），基本类型必须一致**

  * **函数名**和**参数列表**要**一模一样**。 

    ![](images\方法重写.PNG)

  虽然在子类中可以存在与父类中**private**和**static**方法相同名称的方法，和类相关，所以并**不是重写**

* **super、this内存图**

  父类空间优先于子类对象产生。在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空 间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构 造方法调用时，一定先调用父类的构造方法。

  ![](images\03-super与this的内存图.png)

* Java中**继承的特征**

  * Java只支持**单继承**，不支持多继承
  * Java支持**多层继承**(继承体系)。顶层父类是Object类，所有的类默认继承Object，作为父类。 
  * 子类和父类是一种相对的概念。





### 2.3.4 抽象类（abstract）

* **抽象方法**：**没有方法主体**（没有大括号）的方法，用`abstract`修饰，`;`结束
* **抽象类**：==**包含抽象方法的类必须声明为抽象类**，但**抽象类可以不包含任何抽象方法**==
  * **抽象类不能被实例化**（可能包含抽象方法，但没有方法体无法调用）
  * 可以**创建子类继承`(extends)`**并**重写父类所有抽象方法**，否则该子类须声明为抽象类（最终必有实现类否则无意义）
* **抽象类成员特点：**
  1. 成员变量：有变量，有常量
  2. 成员方法：有抽象，有非抽象
  3. **构造方法**：有，用于**子类创建对象时初始化父类成员**（因为子类构造中，有默认的`super()`.）
  4. 静态代码块：可以有



### 2.3.5 接口（interface）

* Java中接口就是多个**类的公共规范标准**，是方法的集合。是**引用数据类型**，用`interface`修饰，也会被编译成`.class`文件

* 接口中包含的内容有：

  * ==JDK7：**常量（静态）**、**抽象方法**==

    * 接口中成员变量必须是**赋值的常量**且**静态**的，默认修饰符`public static final`（大写、下划线）
    * 接口中成员方法必须是抽象方法，默认修饰符`public abstract`

  * ==JDK8：**默认方法（default ）**、**静态方法（static）**==

    * 默认方法：供**实现类直接调用**或者**重写**。可以解决接口升级问题、拼接函数模型

      ```java
      public default 返回值类型 method(/*参数列表*/) { //default不可省略，public可省略
          //方法体     
      }
      ```

    * 静态方法：**接口直接调用**，不能用接口实现类对象来调用（因为可能实现多接口）

      ```java
      public static 返回值类型 method(/*参数列表*/) { //static不可省略，public可省略
          //方法体         
      }
      ```

  * ==JDK9：**私有方法**==

    * 私有方法：向上抽取重复代码，只能供**接口自己**中的**默认方法**或者**静态方法调用**

      ```java
      private 返回值类型 method(/*参数列表*/) { 
          //方法体     
      }
      ```

      ```java
      private static 返回值类型 method(/*参数列表*/) {
          //方法体         
      }
      ```

* 同样的，接口不可以被实例化，需要定义一个类**实现`(implements)`接口中所有方法**，如果这个类是**抽象类，实现部分**即可

* **注意：**

  * 接口**没有静态代码块**或**构造方法**（其实现类继承`Object`，提供无参构造）
  * 一个类的直接父类是唯一的，但一个**类可以实现多个接口**（用“,”隔开）
  * 实现类实现的多个接口中，存在**重复的抽象方法**，那么**只需重写一次**即可
  * 实现类实现的多个接口中，存在**重复的默认方法**，那么**必须重写**冲突的默认方法
  * 实现类的**直接父类中的方法**和**接口中默认方法产生冲突**，则优先**使用父类**中的方法

* **类与接口关系总结**：

  1. 类与类：继承关系，只能单继承，可以多层继承
  2. 类与接口：实现关系，可以单实现，也可以多实现，可以在继承一个类时实现多个接口
  3. 接口与接口：继承关系，可以单继承，也可以多继承
     - 多继承中，如果父接口中的默认方法（抽象方法）有重名的，那么子接口须重写一次。



### 2.3.6 多态

* **多态**： 是指**一个对象有多种形态**。 

* **前提（重点）**

  * **继承**或者**实现**【二选一】 

  * **方法的重写**【意义体现：不重写，无意义】 

  * **父类引用指向子类对象**【格式体现】 

    ```java
    父类 对象名 = new 子类();
    接口名 对象名 = new 实现类();
    ```

* **多态中成员访问特点（继承中也一致）**

  * ==成员变量：编译看左边，运行看左边==
  * ==静态方法或变量：编译看左边，运行看左边（与类相关）==
  * ==**成员方法**：编译看**左**边，运行看**右**边（**依赖对象，因为有方法重写**）==
  * ==构造方法：创建子类对象时访问父类构造方法对父类成员进行初始化==

* 对象的**向上转型**，一定是**安全**的。但**无法访问子类特有方法**，可以限制对特有功能的访问

  * 其实就是多态的写法，如`Fu f = new Zi();`由小范围转向大范围，类似自动类型转换

* 对象的**向下转型**，**不一定安全`(ClassCastException)`**。将父类对象**还原**为**==本来的子类对象==**

  * `Zi zi = (Zi) f;`由大范围转向小范围，类似强制类型转换
  * `instanceof`用于**判断引用数据类型的具体类型**，返回布尔值，如`if(f instanceof Zi){}`

* 笔记本USB接口案例

  ![](images\06-笔记本电脑案例分析.png)

### 2.3.7 一个对象的实例化过程

1. JVM加载`main()`所属的类的`.class`文件，**若有基类则先加载基类**（总是在使用时加载其`.class`文件）

   执行**根基类**对应`.class`中**static初始化**（<u>静态成员变量和静态代码块，按其定义顺序执行</u>)，然后是下一个派生类的static初始化，以此类推。（类**第一次**被加载或创建对象或访问静态数据成员时）

2. 在用构造器**创建对象**时，在**堆中为对象分配空间**，执行构造器初始化

   1. 先根据隐藏的第一行**`super()`**来到**根基类**的无参构造器
   2. 执行根基类的**非静态成员变量的默认初始化，显式初始化**和**构造代码块的初始化**（<u>后俩按其定义顺序执行</u>）
   3. 然后执行根基类**构造器定义的初始化**
   4. 然后执行下一个派生类的`super()`后的以上操作

3. 初始化完毕后，将地址**赋值**给引用变量。

【注意】方法重写

```java
public class Father{
    private int i = test();
    private static int j = method();

    static{
        System.out.print("1 ");
    }
    public Father(){
        System.out.print("2 ");
    }
    {
        System.out.print("3 ");
    }
    public int test() {
        System.out.print("4 ");
        return 1;
    }
    public static int method() {
        System.out.print("5 ");
        return 1;
    }
}
```

```java
public class Son extends Father{
    private int i = test();
    private static int j = method();

    static{
        System.out.print("6 ");
    }
    public Son(){
        System.out.print("7 ");
    }
    {
        System.out.print("8 ");
    }
    public int test(){
        System.out.print("9 ");
        return 1;
    }
    public static int method(){
        System.out.print("10 ");
        return 1;
    }

    public static void main(String[] args) { //也可以放在其他类中
        Son son1 = new Son();//5 1 10 6 9 3 2 9 8 7 
        System.out.println();
        Son son2 = new Son();//9 3 2 9 8 7 
    }
}
```







## <span name="final">2.4 final 关键字</span>

* **ﬁnal**：用于**修饰不可改变内容**。可以用于修饰类、方法和变量。 
  * **类**：被修饰的类，**不能被继承**。 
  * **方法**：被修饰的方法，**不能被重写**。 
  * **局部变量**：
    * 基本类型：只能**赋值一次**，**不能再更改**。
    * 引用类型：只能指向一个对象，**地址不能再更改**。不影响内部成员变量的修改
  * **成员变量**
    * 由于成员变量有默认值，用final修饰后**必须手动赋值**，否则编译失败
    * 要么**显示初始化**；要么通过**全部的构造方法赋值**（并删除setter）
* **abstract和final不能同时使用**。abstract修饰类、方法是需要被实现、重写的，与final矛盾
* **abstract和static不能同时使用**。abstract修饰的方法没有方法体，static修饰的方法可以类名调用，编译失败



## 2.5 package

- **package**

  - 专门用于存放类，在声明时使用`package`语句，并且声明只能位于Java源文件的**第一行**

    ```java
    package cn.itcast.chapter01; //package关键字声明包
    public class Hello{...}
    ```

  - 生成与包名对应目录(目录中可以是绝对地址、相对地址、“.”可以表示当前目录)，运行时要加上包名

    ```java
    javac -d [目录] Hello.java
    cd 目录
    java cn.itcast.chapter01.Hello
    ```

- **import**

  - 导包，import一般出现在package后，类定义之前

    ```java
    import cn.itcast.chapter01.Hello;//导入MAIN类
    import cn.itcast.chapter01.*;//导入包中所有类
    ```

  - **Java中常用包**

    ```java
    java.lang:Java语言核心类，如String、Math、System、Thread等，系统自动导入，无需import
    java.util:工具类、集合类，如Arrays、List、Set等
    java.net:网络编程相关类和接口
    java.io:输入输出相关类和接口
    java.awt:构建图形界面（GUI）相关类和接口
    ```

- **jar**

  - Java Archive File，Java档案文件，是一种压缩文件，独立于任何操作系统

  - **步骤：**

    1. **编译生成**与包名对应目录的**class文件**

       ```
       java -d . Hello.java
       ```

    2. 利用**jar命令**将cn及其目录下的文件都**压缩成jar包**

       ```
       jar -cvf Hello.jar cn
       ```

    3. 由于目前jar包中没有**主清单属性**，修改jar包`META-INF`中`MANIFEST.MF`文件，**指定main方法所在类**

       ```
       Main-Class: cn.itcast.chapter01.Hello	//注意“:”后有空格
       ```

    4. **运行jar包**

       ```
       java -jar Hello.jar
       ```

    5. **解压jar包**

       ```
       jar -xvf Hello.jar
       ```



## 2.6 权限修饰符

- **权限修饰符（访问控制）**

  - **private（类访问级别）**：被修饰的类成员只能被**该类其他成员**访问
  - **default（包访问级别）**：**类或类成员**没有修饰符为默认访问级别，只能被**本包中其他类**访问
  - **protected（子类访问级别）**：被修饰的类成员能被**本包中其他类**、**不同包中该类子类**访问
  - **public（公共访问级别）**：**类或类成员**能被所有都能访问

- **访问控制级别**

  |  访问范围  | private | default | protected | public |
  | :--------: | :-----: | :-----: | :-------: | :----: |
  |   同一类   |    √    |    √    |     √     |   √    |
  |   同一包   |         |    √    |     √     |   √    |
  | 不同包子类 |         |         |     √     |   √    |
  |    全局    |         |         |           |   √    |



## 2.7 内部类

- **内部类**：将**一个类A定义在另一个类B里面**，里面的那个类A就称为内部类，B则称为外部类。 

- 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名 和\$符号 。比如，`Person$Heart.class`

- 特点：（铁扇公主肚子里的孙猴子）

  - **内部类可以直接访问外部类的成员**，**包括私有成员**。 
  - **外部类要访问**内部类的成员，必须要**建立内部类的对象**。

- 分类：

  - **成员内部类**：：定义在**类中方法外**的类

    * **`Outer.Inner in = new Outer().new Inner();`**直接访问外部类中内部类成员

    * 如果出现了**重名**现象，**访问外部类成员变量**格式是：**`外部类名称.this.外部类成员变量名`**

      【面试】

      ```java
      class Outer {
          public int num = 10;
      
          class Inner {
              public int num = 20;
      
              public viod show() {
                  int num  = 30;
      
                  System.out.println(num);//30
                  System.out.println(this.num);//20
                  System.out.println(Outer.this.num);//10
              }
          }
      }
      ```

  - **静态内部类**(`Outer.Inner in = new Outer.Inner();`)**不用创建外部类对象**，相当于外部类

    - 静态内部类只能访问外部类中的静态成员

    - 静态内部类中可以定义静态成员，==**非静态内部类中不允许定义静态成员**==

      【面试】

      ```java
      public class Test {
          public void func() {
              //位置1
          }
      
          class Inner {
          }
      
          public static void main(String[] args) {
              Test test = new Test();
              //位置2
          }
          //在位置1写 new Inner()  可以，外部类访问内部类要创建内部类对象
          //在位置2写 new Inner()  不可以，main方法时静态的，不能调用非静态内部类
          //在位置2写 new test.Inner()  不可以，不是静态内部类，可以test.new Inner()
          //在位置2写 new Test.Inner()  不可以，类名调用只能调用静态成员，除非内部类为静态
      }
      ```

  - **局部内部类**（包含**匿名内部类**）：定义在**方法内部**的类，只有==**当前所属方法才能使用它**==

    - 局部内部类，如果**访问所在方法的局部变量**，那么这个局部变量必须是【有效**final**的】

      备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。

      > new出来的对象在堆内存当中。
      >
      > 局部变量是跟着方法走的，在栈内存当中。
      >
      > 方法运行结束之后，立刻出栈，局部变量就会立刻消失。
      >
      > 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。

  - ==**匿名内部类**：是内部类的简化写法。它的本质是一个**带具体实现的父类或者父接口的匿名的子类对象**==

    - **前提**：匿名内部类必须**继承一个父类**或者**实现一个父接口**。 

    ```java
    接口名称 对象名 = new 接口名称() { //new代表创建对象的动作；接口名称就是匿名内部类需要实现哪个接口
        // 覆盖重写所有抽象方法
    }; //{...}这才是匿名内部类的内容
    ```

    * **使用场景：**方法的参数是接口或抽象类，并且其中的方法不超过三个，嫌麻烦为了不写实现类或子类
    * 注意几点问题：
      * **匿名内部类**，在【**创建对象**】的时候，**只能使用唯一一次**。如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。
      * **匿名对象**，在【**调用方法**】的时候，**只能调用唯一一次**。如果希望同一个对象，调用多次方法，那么必须**给对象起个名字**。
      * 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】

- 定义一个类的时候，权限修饰符规则：

  * 外部类：public / (default)

  * 成员内部类：public / protected / (default) / private

  * **局部内部类**：什么都不能写

    ```java
    public class Demo {
        public static void main(String[] args) {
            new Demo(){ //匿名对象，匿名内部类
                void show(){
                    System.out.println("hello");
                }
            }.show();//hello
            //若是给对象起名，并用该名调用show方法，则编译不通过，因为父类中没有此方法，当前所属方法才能使用它
        }
    }
    ```