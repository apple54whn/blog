# 1 入门 <Badge text="beta" type="warn"/> <Badge text="0.0.1+"/>

## 1.1 环境搭建等基础

* **命令提示符**

  | 命令含义         | 命令提示符（cmd）          | Windows PowerShell |
  | ---------------- | -------------------------- | ------------------ |
  | 切换盘符         | c: **或** C:               | 同左               |
  | 进入文件夹       | cd 文件夹名称              | 同左               |
  | 进入多级文件夹   | cd 文件夹1\文件夹2\文件夹3 | 同左               |
  | 返回上一级       | cd ..                      | 同左               |
  | 直接回根路径     | cd \ **或** cd /           | 同左               |
  | 查看当前目录内容 | dir                        | dir **或** ls      |
  | 清屏             | cls                        | cls **或** clear   |
  | 删除文件         | del                        | del **或** rm      |
  | 退出             | exit                       | exit               |

* **JVM**

  * JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 
  * **跨平台**：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系 统上，这个特性称为**Java语言的跨平台特性**。该特性是**由JVM实现的**，我们编写的程序运行在JVM上，而**JVM** 运行在操作系统上，**不具有跨平台特性**，每个操作系统下都有不同版本的虚拟机。

* **JRE 和 JDK** 

  * JRE(Java Runtime Environment)：是Java程序的运行时环境，包含 **JVM** 和**运行时所需要的核心类库** 。
  * JDK (Java Development Kit)：是Java程序开发工具包，包含 **JRE** 和**开发人员使用的工具**。

* 安装及环境变量配置

  * JAVA_HOME
  * Path

* 编译与运行

  * **编译**：**javac** Test.java
  * **运行**：**java** Test

## 1.2 关键字

* 完全**小写**的字母（**main不是**）

* 在增强版的记事本当中（例如Notepad++）有特殊颜色

   public 、 class 、 static 、  void 、

## 1.3 标识符

* 指在程序中，我们**自己定义内容**。比如类的名字、方法的名字和变量的名字等等
  * **命名规则**： 硬性要求
    * 标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。 
    * 标识符不能以数字开头。 
    * 标识符不能是关键字
  * **命名规范**： 软性建议
    * 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。 
    * 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。 
    * 变量名规范：全部小写。 



## 1.4 数据类型

**字节**是我们常见的计算机中**最小存储单元**

* **分类** 

  * **基本数据类型**：整数型 、 浮点型 、 字符型 、 布尔型 

    | 数据类型     | 关键字         | 内存占用 | 取值范围              |
    | ------------ | -------------- | -------- | --------------------- |
    | 字节型       | byte           | 1个字节  | -128~127              |
    | 短整型       | short          | 2个字节  | -32768~32767          |
    | 整型         | int（默认）    | 4个字节  | -2^31^~2^31^-1        |
    | 长整型       | long           | 8个字节  | -2^63^~2^63^-1        |
    | 单精度浮点数 | ﬂoat           | 4个字节  | 1.4013E-45~3.4028E+38 |
    | 双精度浮点数 | double（默认） | 8个字节  | 4.9E-324~1.7977E+308  |
    | 字符型       | char           | 2个字节  | 0~65535               |
    | 布尔类型     | boolean        | 1个字节  | true，false           |

  * ==**引用数据类型**：**字符串** 、数组 、类 、 接口 、Lambda==

* 注意事项

  * 字符串不是基本类型，而是引用类型。
  * **浮点型**可能只是一个**近似值**，并非精确的值。
  * **数据范围与字节数不一定相关**，如**float数据范围比long更加广泛**，但是float是4字节，long是8字节。
  * 浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。
    如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母。
  * 字符对应ASCII码（0~127）：48—'0'、65—'A'、97—'a'

* **数据类型转换**

  * **自动类型转换**(隐式)，范围**小**的类型向范围**大**的**类型提升**，如下：

    ==**参与运算时byte，short，char**——>**int**——>**long**——>**float**——>**double**(boolean不参与)==

    * ==**编译器的常量优化**==
      * 对于byte、short、char三种类型来说，若右侧赋值的**数值(不能为变量)**没有超过范围，那么javac编译器会自动隐含得帮我们**补上(byte) (short) (char)** ，否则编译报错。
      * 在给变量进行赋值时，若右侧的**表达式都是常量**，没有任何变量，那么javac编译器将会直接将若干个常量表达式计算得到结果。并根据是否超过范围决定编译成功与否。

    ```java
    byte a = 3;
    byte b = 4;
    byte c = a + b;//运算期间byte类型变量自动提升为int，但int类型不能赋值给byte类型，因此编译失败。
    byte d = 3 + 4;//常量在编译的时候（javac），已经确定了 3+4 的结果并没有超过byte类型的取值范围，可以赋值给d，成功
    
    char ch = 'A';
    System.out.println(ch + 1);//66
    ```

  * **强制类型转换**(显式)。一般不推荐使用，有可能发生**精度损失**(浮点转成整数，直接取消小数)，**数据溢出**

    ```java
    int a = 3;
    byte b = (byte)a;
    ```

    ==**在使用+=、-=、*=、/=、%=运算符进行赋值时，强制类型转换会自动完成**==



## 1.5 常量

- **整数**常量、**浮点数**常量、**字符**常量、**字符串**常量、**布尔**常量、**空**常量

## 1.6 变量

* 格式： 数据类型 变量名 = 数据值;
* **注意**：
  * 变量名称：在同一个大括号范围内（**作用域内**），变量的名字不可以相同。 
  * 变量赋值：定义的变量，**不赋值不能使用**。
  * 对于**byte或者short**类型变量，注意其**取值范围**
  * 对于float或者long类型变量，**后缀F、L**不能丢



## 1.7 运算符

* **算术运算符**：【+】【-】【*】【/】【%】【++】【--】

  * ++、--：混合运算时比较麻烦，在单独使用时没有区别，只有**变量**才能使用，常量不能使用

    * 变量前：先算后用
    * 变量后：先用后算

  * +在字符串中的操作： 连接、拼接字符串

    ```java
    int a = 10;
    int b = 20;
    String str = "hello";
    System.out.println(a + b + str);//30hello
    System.out.println(str+a+b);//hello1020
    ```

  * ==**取余和取模**（C、C++、java、JavaScript中%是取余，Python中%是取模），只对于整数有意义==

    ==区别在于第一步的商**趋于0(取余)**、**趋于负无穷(取模)**，**取余和取模同符号数结果相同**==

    ```java
    取余(结果符号取决于被除数)				取模(结果符号取决于模数)
    5%3=2；					 			5%3=2；
    -5%-3=-2;							 -5%-3=-2；
    5%-3=2;								 5%-3=-1；
    -5%3=-2;							 -5%3=1；
    ```

* **赋值运算符**

  * 基本赋值运算符：【=】

  * 复合赋值运算符：【+=】【-=】【*=】【/=】【%=】

    ==**在使用+=、-=、*=、/=、%=复合运算符进行赋值时，强制类型转换会自动完成**==

* **比较运算符**：【==】【<】【>】【<=】【>=】【!=】，结果是布尔值，不能连写
* **逻辑运算符**：是用来连接两个布尔类型结果的运算符，结果是布尔值，可以连写
  * 【**!**】：取反
  * 【**&&**】：短路与，符号左边是false，右边不再运算；若是【&】需运算完
  * 【**||**】：短路或，符号左边是true，右边不再运算；若是【|】需运算完

* **三元运算符**
  * 数据类型 变量名 = 布尔类型表达式？结果1：结果2
    * 必须同时保证结果1和结果2符合左侧数据类型要求
    * 三元运算符的结果必须被使用。赋值或打印

* **位运算符**

  `<<`左移，左边移走部分舍去，**右边补0**

  `>>`右移，右边移走部分舍去，**左边空位按原符号为补0(正数)或1(负数)**

  `>>>`无符号右移，不考虑正负，**左边补0**



## 1.8 方法

* **方法定义格式** 

  ```java
  修饰符 返回值类型 方法名 （参数列表）｛
  	方法体;
  	return 返回值;//停止方法，将返回值返回给调用处
  }
  ```

  * 方法调用

    ```java
    method();
    ```

  * 方法定义**注意事项**： 

    * 方法必须定义在一个**类中** 
    * 方法不能定义在另一个方法的里面，**不能嵌套**
    * 一个方法可以有多个return语句，但必须保证**同时只有一个return会被执行到**，return后不能有语句

* ==**方法重载(overload)**：同一类中**方法名相同**，**参数列表不同**(类型 或 个数 或 多类型顺序 不同)==

  ==与返回值类型无关、与参数名无关==

* **==可变参数==，**写方法中参数个数不明确时可用（同js中arguments类似），**底层为数组**

  * 注意：一个方法**只能有一个**可变参数，且需放在参数列表的**末尾**

  ```java
  public static void sum(int...arr) {
  	int sum = 0;
  	for(int a:arr) {
  		sum+=a;
  	}
  	System.out.println(sum);
  }
  ```

* 

## 1.9  JShell脚本工具 

* JShell**脚本**工具是JDK9的新特性。当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运行，这个时候可以使用JShell工具，**一步一步运行代码**。
* 命令行直接输入`JShell`命令，退出`/exit`



## 1.10 流程控制

* **顺序结构**

* **判断语句**

  * If
  * if...else...
  * if...else if...else...
    * if else 和 三元运算符互换：取两数最大值

* **选择语句**

  * switch语句中**表达式数据类型可以是：byte、short、char、int；enum（枚举）、String(JDK7后)**

    ```java
    switch (表达式) {
        case 常量值1:
            语句1；
                break;
        case 常量值2:
            语句2；
                break;
            ......
        default:
            默认语句
            break;//default的break可省略不写，但不建议
    }
    ```

  * case的**穿透性**

    * 在switch语句中，如果case的后面**不写break**，将出现穿透现象，也就是**不会再判断下一个case**的值，直接向后运行，直到**遇到break**，或者**整体switch结束**。

  * **case后面的值不可重复，否则编译失败**

  * switch语句格式可以很灵活，**前后顺序可以颠倒**，**break语句也可以省略（例如，季节）**

* **循环语句**

  * for：==无论布尔表达式是否满足，**步进表达式都会执行**==（三角形图形，上右，下左）

    ```java
    for(初始化表达式; 布尔表达式; 步进表达式){
        循环体; 
    }
    ```

  * while

    ```java
    初始化表达式;
    while(布尔表达式){
        循环体; 
        步进表达式;
    }
    ```

  * do...while

    ```java
    初始化表达式;     
    do {
    	循环体;
    	步进表达式;
    } while(布尔表达式);
    ```

  * **for 和 while 的区别**

    * 控制条件语句所控制的那个**变量**，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想**继续使用，就用while**，**否则推荐使用for**。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。 
    * 在**已知循环次数**的时候使用推荐使用**for**，**循环次数未知**的时推荐使用**while**。
    * do while 绝对会执行一次。

* **跳出语句**

  * **break**：**终止switch**或者**循环**，用在if中没用
  * **continue**：**结束本次循环**，**继续下一次**的循环

* 扩展知识点

  * 死循环：循环中的条件永远为true，死循环的是永不结束的循环。（**死循环后语句执行不到，编译失败**）
  * 嵌套循环：一个循环的循环体是另一个循环



## 1.11 数组

* **容器**：将多个数据存储到一起，每个数据称为该容器的元素

  * **数组**： 存储数据**长度固定**的容器，多个数据的**数据类型要一致（存在自动类型转换）**。是**引用数据类型**

    * 注意：==数组**对象**有**定长**特性，**长度一旦指定，不可更改**，**不要把变量名看成数组**==

      ```java
      int[] arr1 = new int[3];
      System.out.println(arr1.length);//3
      arr1 = new int[5];
      System.out.println(arr1.length);//5
      ```

* **初始化**：

  * 动态初始化（**必须指定长度，二维数组可以只指定第一个**）

    * ==元素**默认值**：整数类型—0；浮点类型—0.0；字符类型—‘\u0000’；布尔类型—false；引用类型—null==

    ```java
    int[] arr = new int[3];
    int[][] arr = new int[m][];
    int[][] arr = new int[m][n];
    ```

  * 静态初始化（指定内容）

    * 也有元素默认值，但是之后又把大括号内容赋值给数组了

    ```java
    int[] arr = new int[]{1,2,3};
    int[] arr = {1,2,3};//上述的简化版
    int[][] arr = new int[][]{{},{}};
    int[][] arr = {{...},{...}};
    ```


* ==**【注意】字符串有length()方法，数组有length属性**==

* 数组内存图

  ![](images\04-两个引用指向同一个数组的内存图.png)

* 数组反转

  ```java
  public static void reverseArray(int[] arr){
      for (int i = 0; i < arr.length/2; i++) {
          int temp = arr[i];
          arr[i] = arr[arr.length-1-i];
          arr[arr.length-1-i]= temp;
      }
  }
  //或
  public static void reverseArray(int[] arr){
      for (int min=0,max=arr.length-1;min<max;min++,max--) {
          int temp = arr[min];
          arr[min] = arr[max];
          arr[max]= temp;
      }
  }
  ```

* 选择排序：找剩余数组元素中最小的，放在首位

  ```java
  public static void selectSort(int[] arr) {
      for (int i = 0; i < arr.length - 1; i++) {
          for (int j = i + 1; j < arr.length; j++) {
              if (arr[i] > arr[j]) {
                  int temp = arr[i];
                  arr[i] = arr[j];
                  arr[j] = temp;
  ...
  ```

* 冒泡排序：相邻中最大的。。。

  ```java
  public static void bubbleSort(int[] arr){
      for (int i = 0; i < arr.length-1; i++) {
          for(int j=0;j<arr.length-i-1;j++){
              if (arr[j]>arr[j+1]){
                  int temp = arr[j];
                  arr[j] = arr[j+1];
                  arr[j+1] = temp;
  ...
  ```


## 1.12 Java内存划分

1. ==**栈（stack）**：存放的都是**方法中的局部变量**。**方法运行一定要在栈中**==
   - 局部变量：方法的参数，或方法{}内部的变量
   - 作用域：一旦**超出作用域**，立刻从栈内存中**消失**
2. ==**堆（heap）**：凡是**new出来的**，都在堆内存中==
   - 堆内存里东西都有一个**地址值**：16进制
   - 堆内存里数据都有**默认值**。规则如下：
     - **整数类型—0；浮点类型—0.0；字符类型—‘\u0000’；布尔类型—false；引用类型—null**
3. ==**方法区（Method Area）**：存储**.class相关信息**，包含**方法的信息**==
4. 本地方法栈（Native Method Stack）：与操作系统相关
5. 寄存器（PC Register）：与CPU相关



## 1.13 习题

* 对角线画圈

  ```java
  public static void printPic(int num){
      for (int i = 0; i < num; i++) {
          for (int j = 0; j < num; j++) {
              if(j==i||j==num-1-i){
                  System.out.print("O");
              } else {
                  System.out.print("*");
              }
          }
          System.out.println();
      }
  }
  ```

* 定义round方法，接收一位小数，实现四舍五入运算，并返回结果（+0.5，强转int）

  ```java
  public static int round(double d){
      return (int) (d+0.5);
  }
  ```

* 统计字符出现次数。利用容量为26的数组保存字符出现次数

  ```java
  public static void showTimes(char[] chs){
      int[] count = new int[26];
      for (int i = 0; i < chs.length; i++) {
          count[chs[i] - 97]++;
      }
      for (int i=0,ch=97 ;i<count.length;i++,ch++){
          if(count[i]!=0){
              System.out.println("符号"+(char)ch+"出现的次数:"+count[i]);
          }
      }
  }
  ```