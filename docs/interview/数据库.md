# 数据库

## DELETE 与 TRUNCATE 删除表记录区别

* DELETE每次从表中删除一行，并将该操作作为事务记录在**日志**中以便回滚，**不清空 AUTO_INCREMENT 记录**数
* TRUNCATE**直接删除**表并**重新创建**新表，不能回滚， **AUTO_INCREMENT置为0**，**效率比DELETE高**



## 存储过程

一组为了完成特定功能的 SQL 语句集，，经编译后存储在数据库中，可以通过存储过程名称调用



## 索引

对数据库中一或多个列值的排序，帮助数据库高效获取数据的数据结构。有：普通索引、唯一索引、主键索引、全文索引

* 优点：
  * **加快检索速度**
  * 唯一索引确保每行数据的唯一性
  * 在使用索引的过程可以优化隐藏器，提高系统性能
* 缺点：**插入、删除、修改**、维护速度下降，且**占**用物理和数据**空间**



## 事务四大特性（ACID）

* **原子性**（Atomicity）：事务中所有操作是不可再分割的**原子单位**。事务中所有操作要么全部执行成功，要么全部执行失败。
* **一致性**（Consistency）：在事务开始之前和事务结束以后，数据库**状态保持一致**。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。
* **隔离性**（Isolation）：隔离性是指在**并发**操作中，**不同事务之间应该隔离**开来，使每个并发中的事务不会相互干扰。
* **持久性**（Durability）：一旦事务**提交**成功，它**对数据的改变必须是永久**的，即使出现系统故障。



## 并发事务问题与隔离级别

问题：

* 脏读：一个事务读取到另一个事务**未提交**的数据
* 不可重复读：一个事务中**两次读取的数据内容**不一致。这是事务update 时引发的问题。
* 幻读：一个事务中**两次读取的数据的数量不一致**，这是 insert 或 delete 时引发的问题。

**四大隔离级别**（“×”表示会出现这种问题；“ ”表示不会出现这种问题）

| 级别 |   名称   |     隔离级别     | 脏读 | 不可重复读 | 幻读 |  数据库默认隔离级别  |
| :--: | :------: | :--------------: | :--: | :--------: | :--: | :------------------: |
|  1   | 读未提交 | read uncommitted |  ×   |     ×      |  ×   |                      |
|  2   | 读已提交 |  read committed  |      |     ×      |  ×   | Oracle 和 SQL Server |
|  3   | 可重复读 | repeatable read  |      |            |  ×   |        MySQL         |
|  4   |  串行化  |   serializable   |      |            |      |                      |

> 上面的级别最低，下面的级别最高。隔离级别越高，性能越差，安全性越高。 



## 如何进行事务管理

**Connection**的三个方法与事务相关：

- **setAutoCommit**(boolean)：设置是否为自动提交事务，如果true（默认值就是true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置**false**，那么就相当于开启了事务了；
- **commit**()：提交事务
- **rollback**()：回滚事务

还可以设置Savepoint，允许通过代码设置保存点并让事务回滚到指定的保存点



## SQL 优化

* 查询结果**不要用***来查询所有字段，要明确**指明结果字段**

* 对查询进行优化，避免全表扫描，首先应考虑在 **where 及 order by 涉及的列上建立索引**，建立**索引时字段不能有 null 值**
* **索引不是越多越好**。在提高select效率同时，降低了**insert和update**效率（可能会重建索引）。一个表索引数最好不要超过6个

* 根据查询条件，建立索引，如果**查询条件不止一个**时，使用**组合索引**

* **避免在 where 子句中对字段进行 null 值判断、使用!=或<>操作符、使用 or 来连接条件、in 和 not in 也要慎用**，否则将导致引擎放弃使用索引而进行全表扫描

  在查询**条件表达式的左侧尽量不要使用函数**，否则索引失效

  如果有 **like** 话，尽量避免%xxx%两侧都有%的条件，**单侧%可以使用索引**，多侧不可以

## MySQL 数据库优化

* **EXPLAIN** 你的 SELECT 查询
* 当只要**一行数据**时使用 **LIMIT 1**
* 使用 **ENUM** 而**不是 VARCHAR**
* **固定长度的表**会更**快**



## 常用工具

### 慢查询日志

### Explain 执行计划

### Profiling

### 数据库连接进程表

## 引擎

### InnoDB

### MyIsam

### Blackhole



## 主从复制Master/Salve

## 读写分离





## MyBatis 中一级和二级缓存的区别？

一级缓存是 SqlSession 级别的缓存。在操作数据库时需要构造 sqlSession 对象，在对象中有一个(内存区域)数据结构（HashMap）用于存储缓存数据。不同的 sqlSession之间的缓存数据区域（HashMap）是互相不影响的。
  一级缓存的作用域是同一个 SqlSession，在同一个 sqlSession中两次执行相同的 sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个 sqlSession结束后该 sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。 
  二级缓存是 mapper级别的缓存，多个 SqlSession去操作同一个 Mapper的sql语句，多个 SqlSession去操作数据库得到数据会存在二级缓存区域，多个 SqlSession可以共用二级缓存，二级缓存是跨 SqlSession的。 
  二级缓存是多个 SqlSession 共享的，其作用域是 mapper 的同一个 namespace，不同的sqlSession两次执行相同 namespace下的 sql语句且向 sql中传递参数也相同即最终执行相同的 sql 语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis 默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存。 



## 什么是Redis？用处？

Redis是一个**开源的高性能key-value数据库**。应用场景如下：

- **缓存**（数据查询、短连接、新闻内容、商品内容等等）
- **队列**（秒杀、抢购、12306等等）
- 发布/订阅

- 排行榜/计数器



## Redis相比 memcached 有哪些优势？

- Redis**速度**比memcached快很多
- Redis支持丰富的**数据类型**，memcached所有值都是简单的字符串类型
- Redis可以**持久化**数据



