# 多线程

## 线程 & 进程

**进程**：是**程序**的一次**执行过程**，是系统进行资源分配和处理机调度的基本单位

**线程**：线程是进程中的一个**执行路径**，线程只拥有必不可少的资源如程序计数器、一组寄存器和栈。共享同属进程的全部资源。

Java 程序运行原理：Java命令启动JVM（相当于启动了一个进程），由该进程创建启动多个线程，至少两个线程可以分析出来。**执行main()函数的主线程**，**负责垃圾回收的线程**

多线程执行时，其实**每一个执行线程**都有一片自己**所属的栈内存**空间。进行**方法的压栈和弹栈**

## 创建线程的方式

> start本质是先启动线程，再由JVM取调用该线程的run方法（直接调用run方法调用的是普通方法）

- **继承 Thread 并重写run方法**，创建Thread子类对象并调用start方法（多次调用start会抛异常 **IllegalThreadStateException**）

- **实现 Runnable 接口并重写run方法**，**创建Thread对象并将该接口和线程名传入**，调用Thread对象的start方法

  好处是避免单继承的局限性；适合多个相同线程处理同一资源；解耦，代码和线程独立；

- **实现 Callable 接口并重写call方法**，其实现类用 **FutureTask 类来封装**，并**将FutureTask传入Thread的构造**方法中，调用Thread对象start方法。可以**调用FutureTask的get**方法，阻塞等待任务代码执行完毕，获取返回值。

- 利用Executors工厂类来创建线程池。



## 如何实现线程间的通讯

- synchronized+wait+notifyAll

  - wait：等待并**释放锁**，线程被**阻塞**，被唤醒后若获得锁那么从这里执行后续代码

  - notify/All：唤醒该锁上的所有线程，被通知线程不能立即恢复执行线程，**重新请求同步锁**。但是**notifyAll不会释放锁**

    notify有可能会再次唤醒生产者/消费者，导致最终都在wait

- ReentrantLock+Condition+await+signalAll

  - 可以实现更细粒度的锁控制，且可以精确控制唤醒的线程

## sleep() 和 wait() 有什么区别

- sleep是 Thread 的方法，会使调用的线程**休眠**指定时间，且**不会释放锁**，休眠结束回到就绪状态
- wait 是 Object 的方法，**等待**并立即**释放锁**，线程被阻塞。**被唤醒后若获得锁那么从这里执行后续代码**。在同步中调用



## Java 中能创建 volatile 数组吗？

可以，这个**volatile变量只是**指向数组的**引用**。若改变引用则受到volatile的保护，但是若是改变数组中的元素，volatile则没作用



## volatile 能使得一个非原子操作变成原子操作吗？





## 三个线程依次打印ABC

```java
public class Test2 {

    Lock lock = new ReentrantLock();
    Condition A = lock.newCondition();
    Condition B = lock.newCondition();
    Condition C = lock.newCondition();
    int num = 0;

    public void soutA() {
        lock.lock();
        try {
            while (true) {
                while (num % 3 != 0) {
                    A.await();
                }
                System.out.println("A");
                num++;
                B.signal();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }

    public void soutB() {
        lock.lock();
        try {
            while (true) {
                while (num % 3 != 1) {
                    B.await();
                }
                System.out.println("B");
                num++;
                C.signal();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void soutC() {
        lock.lock();
        try {
            while (true) {
                while (num % 3 != 2) {
                    C.await();
                }
                System.out.println("C");
                num++;
                A.signal();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        Test2 t = new Test2();
        new Thread(t::soutA).start();
        new Thread(t::soutB).start();
        new Thread(t::soutC).start();
    }
}
```

## 十个线程依次输出0123456789

```java
public class Test {

    private static int num = 0;

    public static synchronized void printNum() {
        System.out.println(Thread.currentThread().getName() + ":" + num++);
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            Thread thread = new Thread(Test::printNum);
            thread.start();
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
public class Test {

    static int orderNum = 0;

    static Object lockObj = new Object();

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(new Th(i)).start();
        }
    }
}

class Th implements Runnable {

    int owrNum;

    public Th(int owrNum) {
        this.owrNum = owrNum;
    }

    @Override
    public void run() {
        synchronized (Test.lockObj) {
            if (Test.orderNum < 10) {
                try {
                    while (owrNum != Test.orderNum) {
                        Test.lockObj.wait();
                    }
                    System.out.println(Thread.currentThread().getName() + ":" + owrNum);
                    Test.orderNum++;
                    Test.lockObj.notifyAll();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }
    }
}
```

