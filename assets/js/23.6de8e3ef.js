(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{153:function(v,_,t){"use strict";t.r(_);var r=t(0),a=Object(r.a)({},function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"项目技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#项目技术","aria-hidden":"true"}},[v._v("#")]),v._v(" 项目技术")]),v._v(" "),t("h2",{attrs:{id:"购物车使用了-cookied-和-redis-缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#购物车使用了-cookied-和-redis-缓存","aria-hidden":"true"}},[v._v("#")]),v._v(" 购物车使用了 Cookied 和 Redis 缓存")]),v._v(" "),t("p",[v._v("当用户在"),t("strong",[v._v("未登录")]),v._v("的情况下，将此购物车存入"),t("strong",[v._v("cookies")]),v._v(" , 在用户登陆的情况下，将购物车数据存入"),t("strong",[v._v("redis")]),v._v("  。如果用户登陆时，cookies 中存在购物车，需要将cookies的购物车"),t("strong",[v._v("合并")]),v._v("到 redis 中存储。，"),t("strong",[v._v("降低了数据库的读写次数，提升服务性能")]),v._v("。")]),v._v(" "),t("ul",[t("li",[v._v("存储的是：商家ID、商家名称、购物车列表（存储商品明细），采用组合实体类封装")]),v._v(" "),t("li",[v._v("传入数据：SKU ID、SKU数量（可能为负数）")])]),v._v(" "),t("blockquote",[t("p",[t("code",[v._v('access="IS_AUTHENTICATED_ANONYMOUSLY"')]),v._v(" 用于设置"),t("strong",[v._v("资源可以在不登陆时可以访问")]),v._v("，此配置与 "),t("code",[v._v('security="none"')]),v._v("的区别在于当用户未登陆时获取登陆人"),t("strong",[v._v("账号的值为"),t("code",[v._v("anonymousUser")])]),v._v(" ，而"),t("code",[v._v('security="none"')]),v._v("的话，无论是否登陆都不能获取登录人账号的值（在获取时就报空指针异常，因为不走SpringSecurity）")])]),v._v(" "),t("p",[v._v("利用Spring Security获取当前登录的用户名，存在如下两种情况：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("未登录")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("从Cookie中"),t("strong",[v._v("提取我的购物车")])])]),v._v(" "),t("li",[t("p",[v._v("向Cookie中"),t("strong",[v._v("添加商品")])]),v._v(" "),t("p",[v._v("因为有第三方商家，所以需要判断"),t("strong",[v._v("该商品所属商家的购物车是否在我的购物车中")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("不存在则"),t("strong",[v._v("创建商品所属的商家购物车")]),v._v("，并"),t("strong",[v._v("添加到的购物车列表中")])])]),v._v(" "),t("li",[t("p",[v._v("存在则需要"),t("strong",[v._v("判断")]),v._v("当前"),t("strong",[v._v("商品")]),v._v("是否存在于商家购物车")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("不存在则"),t("strong",[v._v("创建商品")]),v._v("明细并"),t("strong",[v._v("添加至该商家购物车")]),v._v("中")])]),v._v(" "),t("li",[t("p",[v._v("存在则修改商品数量即可")]),v._v(" "),t("p",[v._v("数量为0时则删除该商品；购物车列表长度小于等于0时删除该商家购物车")])])])])])]),v._v(" "),t("li",[t("p",[v._v("最终将我的购物车"),t("strong",[v._v("存入Cookie")])])])])]),v._v(" "),t("li",[t("p",[v._v("已登录")]),v._v(" "),t("ol",[t("li",[v._v("从Redis中"),t("strong",[v._v("提取我的购物车")]),v._v("，根据登陆名称存放的")]),v._v(" "),t("li",[v._v("查询"),t("strong",[v._v("Cookie中是否存在")]),v._v("我的购物车（size>0），存在则"),t("strong",[v._v("合并我的购物车")]),v._v("（遍历，并调用上面1.2中方法）")]),v._v(" "),t("li",[v._v("向购物车"),t("strong",[v._v("添加商品")]),v._v("（还是上面1.2中方法）")]),v._v(" "),t("li",[v._v("最终将我的购物车"),t("strong",[v._v("存入Redis")])])])])]),v._v(" "),t("h2",{attrs:{id:"dubbo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dubbo","aria-hidden":"true"}},[v._v("#")]),v._v(" Dubbo")]),v._v(" "),t("p",[v._v("dubbo 在我们项目中主要用来实现"),t("strong",[v._v("不同系统之间的服务调用")]),v._v("，由于我们项目是"),t("strong",[v._v("按照不同的功能分了不同的系统")]),v._v("，按照三层架构又"),t("strong",[v._v("分了不同的服务")]),v._v("，其中三层架构中的"),t("strong",[v._v("控制层作为服务的消费方")]),v._v("，"),t("strong",[v._v("业务层和持久层共同作为服务的发布方")]),v._v("，这样的架构实现了"),t("strong",[v._v("系统的服务化，提高了开发效率，实现了业务的解耦")]),v._v("。")]),v._v(" "),t("p",[v._v("我们主要在服务的暴露方通过"),t("code",[v._v("<dubbo:service>")]),v._v("标签来暴露服务，在服务的消费方通过"),t("code",[v._v("<dubbo:reference>")]),v._v("标签来引用服务，注册中心我们选用的是 zookeeper，对服务的URL 进行了管理和配置。")]),v._v(" "),t("ul",[t("li",[v._v("Dubbo 是阿里开源的 "),t("strong",[v._v("RPC（远程过程调用） 的分布式框架")]),v._v("，提供了 SOA 服务治理方案。有5个分为是Provider（服务\n的提供方）、Consumer（服务的消费方）、Container（容器）、Registry（注册中心）、Monitor（监控中心）")]),v._v(" "),t("li",[t("strong",[v._v("注册中心")]),v._v("：只负责"),t("strong",[v._v("发现和注册服务")]),v._v("。不参与数据传输，不转发请求，压力较小\n"),t("ul",[t("li",[v._v("注册中心宕机问题\n"),t("ul",[t("li",[v._v("注册中心会集群部署，其中一台宕机，自动切换到另一台。")]),v._v(" "),t("li",[v._v("全部宕机后还可以通过本地缓存通信")])])])])]),v._v(" "),t("li",[t("strong",[v._v("监控中心")]),v._v("：负责统计各"),t("strong",[v._v("服务调用次数、调用时间")]),v._v("等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示")])]),v._v(" "),t("p",[v._v("在使用Duubo 的过程中你们遇到过什么问题？")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("序列化和反序列化异常")]),v._v(" "),t("p",[v._v("调用服务，出现消息发送失败的时候，通常是接口方法的"),t("strong",[v._v("传入传出参数是新增加的扩展类")]),v._v("，"),t("strong",[v._v("没有实现序列化接口")])])]),v._v(" "),t("li",[t("p",[v._v("怎么禁止一个服务？")]),v._v(" "),t("p",[t("strong",[v._v("通过监控中心")]),v._v("的可视化界面，我们可以对具体的服务设置禁止，也可以设置对应的权重")])])]),v._v(" "),t("h2",{attrs:{id:"zookeeper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper","aria-hidden":"true"}},[v._v("#")]),v._v(" Zookeeper")]),v._v(" "),t("h3",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介","aria-hidden":"true"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("p",[v._v("我们项目中主要用 zookeeper 作为 Dubbo 的"),t("strong",[v._v("注册中心")]),v._v("，集中"),t("strong",[v._v("管理所有服务的 URL")]),v._v("；同时集中的管理集群的配置。")]),v._v(" "),t("p",[v._v("为什么要用zookeeper 作为dubbo 的注册中心？")]),v._v(" "),t("p",[v._v("zookeeper 的"),t("strong",[v._v("数据全部存储在内存中")]),v._v("，性能高；其次， zookeeper 也"),t("strong",[v._v("支持集群")]),v._v("，实现了高可用；同时基于 zookeeper 的特性，也支持"),t("strong",[v._v("事件监听")]),v._v("（服务的暴露方发生变化，可以进行推送），所以zookeeper 适合作为 dubbo 的注册中心区使用。")]),v._v(" "),t("h3",{attrs:{id:"集群简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集群简介","aria-hidden":"true"}},[v._v("#")]),v._v(" 集群简介")]),v._v(" "),t("p",[v._v("为什么搭建Zookeeper集群？")]),v._v(" "),t("ul",[t("li",[v._v("大部分分布式应用需要一个主控、协调器或者控制器来管理物理分布的子进程。目前，大多数都要开发私有的协调程序，缺乏一个通用机制，协调程序的反复编写浪费，且难以形成通用、伸缩性好的协调器，zookeeper提供通用的分布式锁服务，用以协调分布式应用。所以说zookeeper是分布式应用的协作服务。")]),v._v(" "),t("li",[v._v("zookeeper"),t("strong",[v._v("作为注册中心，服务器和客户端都要访问，如果有大量的并发肯定会有等待。所以可通过zookeeper集群解决。")])])]),v._v(" "),t("hr"),v._v(" "),t("p",[t("strong",[v._v("Leader选举")])]),v._v(" "),t("p",[v._v("Zookeeper的启动过程中leader选举是非常重要而且最复杂的一个环节。那么什么是leader选举呢？zookeeper为什么需要leader选举呢？zookeeper的leader选举的过程又是什么样子的？")]),v._v(" "),t("p",[v._v("首先我们来看看什么是leader选举。其实这个很好理解，leader选举就像总统选举一样，每人一票，获得多数票的人就当选为总统了。在zookeeper集群中也是一样，每个节点都会投票，如果某个节点获得"),t("strong",[v._v("超过半数以上的节点的投票")]),v._v("，则该节点就是leader节点了。")]),v._v(" "),t("blockquote",[t("p",[v._v("以一个简单的例子来说明整个选举的过程：\n假设有**五台服务器组成的zookeeper集群,**它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数据量这一点上,都是一样的.假设这些服务器依序启动,来看看会发生什么 。")]),v._v(" "),t("ol",[t("li",[v._v("服务器1启动,此时只有它一台服务器启动了,它发出去的报没有任何响应,所以它的选举状态一直是LOOKING状态")]),v._v(" "),t("li",[v._v("服务器2启动,它与最开始启动的服务器1进行通信,互相交换自己的选举结果,由于两者都没有历史数据,所以id值较大的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3),所以服务器1,2还是继续保持LOOKING状态.")]),v._v(" "),t("li",[v._v("服务器"),t("strong",[v._v("3")]),v._v("启动,根据前面的理论分析,服务器3成为服务器1,2,3中的老大,而与上面不同的是,此时有三台服务器选举了它,所以它成为了这次选举的"),t("strong",[v._v("leader")]),v._v(".")]),v._v(" "),t("li",[v._v("服务器4启动,根据前面的分析,理论上服务器4应该是服务器1,2,3,4中最大的,但是由于前面已经有半数以上的服务器选举了服务器3,所以它只能接收当小弟的命了.")]),v._v(" "),t("li",[v._v("服务器5启动,同4一样,当小弟")])])]),v._v(" "),t("h2",{attrs:{id:"rabbitmq"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq","aria-hidden":"true"}},[v._v("#")]),v._v(" RabbitMQ")]),v._v(" "),t("h3",{attrs:{id:"为什么使用消息队列？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用消息队列？","aria-hidden":"true"}},[v._v("#")]),v._v(" 为什么使用消息队列？")]),v._v(" "),t("p",[v._v("我们CMS服务有个发布接口，发布成功后需要将生成的静态HTML文件下载到其对应的服务器。可以使用MQ来实现解耦和异步")]),v._v(" "),t("h3",{attrs:{id:"消息队列有什么优缺点？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列有什么优缺点？","aria-hidden":"true"}},[v._v("#")]),v._v(" 消息队列有什么优缺点？")]),v._v(" "),t("ul",[t("li",[v._v("优点：解耦、异步、削峰")]),v._v(" "),t("li",[v._v("缺点："),t("strong",[v._v("系统复杂度提高")]),v._v("、"),t("strong",[v._v("可用性")]),v._v("降低，会有"),t("strong",[v._v("一致性")]),v._v("问题")])]),v._v(" "),t("h3",{attrs:{id:"activemq、rabbitmq、rocketmq、kafka-有什么优缺点？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#activemq、rabbitmq、rocketmq、kafka-有什么优缺点？","aria-hidden":"true"}},[v._v("#")]),v._v(" ActiveMQ、RabbitMQ、RocketMQ、Kafka 有什么优缺点？")]),v._v(" "),t("ul",[t("li",[v._v("ActiveMQ：社区不活跃")]),v._v(" "),t("li",[v._v("RabbitMQ：时效性为微秒级，基于erlang开发，并发性好")]),v._v(" "),t("li",[v._v("RocketMQ：阿里开源，捐赠给Apache，功能完善，分布式。可以消息0丢失")]),v._v(" "),t("li",[v._v("Kafka：用于大数据领域")])]),v._v(" "),t("h3",{attrs:{id:"如何保证消息队列的高可用？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息队列的高可用？","aria-hidden":"true"}},[v._v("#")]),v._v(" 如何保证消息队列的高可用？")]),v._v(" "),t("p",[v._v("采用镜像集群模式。创建的 queue，无论元数据还是 queue 里的消息都会"),t("strong",[v._v("存在于多个实例上")]),v._v("，每次你写消息到 queue 的时候，都会自动把"),t("strong",[v._v("消息同步")]),v._v("到多个实例的 queue 上。")]),v._v(" "),t("h3",{attrs:{id:"如何保证消息不被重复消费？如何保证消息消费的幂等性？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息不被重复消费？如何保证消息消费的幂等性？","aria-hidden":"true"}},[v._v("#")]),v._v(" 如何保证消息不被重复消费？如何保证消息消费的幂等性？")]),v._v(" "),t("p",[v._v("保证"),t("strong",[v._v("被消费的数据在数据库中只有一条记录！")])]),v._v(" "),t("ul",[t("li",[v._v("每次写数据库时根据主键之类"),t("strong",[v._v("查询")]),v._v("，有就不保存了")]),v._v(" "),t("li",[v._v("Redis每次都是set，天然幂等")]),v._v(" "),t("li",[v._v("若是用类似"),t("strong",[v._v("分布式id等全局id，消费前查询一下")]),v._v("，保证别重复消费即可。或用"),t("strong",[v._v("唯一约束")]),v._v("来制约")])]),v._v(" "),t("h3",{attrs:{id:"如何保证消息的可靠性传输？如何处理消息丢失的问题？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息的可靠性传输？如何处理消息丢失的问题？","aria-hidden":"true"}},[v._v("#")]),v._v(" 如何保证消息的可靠性传输？如何处理消息丢失的问题？")]),v._v(" "),t("blockquote",[t("p",[v._v("不用RabbitMQ的事务机制，同步会吞吐量下降，损耗性能")])]),v._v(" "),t("ul",[t("li",[t("p",[v._v("MQ开启"),t("strong",[v._v("持久化")]),v._v("，持久化交换机/队列/消息")])]),v._v(" "),t("li",[t("p",[v._v("生产者开启"),t("strong",[v._v("confirm模式")]),v._v("（分配id），发送到MQ并持久化则返回成功，否则返回失败，此时可以重试。定时重试")])]),v._v(" "),t("li",[t("p",[v._v("消费者关闭"),t("strong",[v._v("自动ACK机制")]),v._v("，在处理完业务后才ACK，否则MQ会把消息交给其他消费者处理")])])]),v._v(" "),t("h3",{attrs:{id:"如何保证消息的顺序性？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息的顺序性？","aria-hidden":"true"}},[v._v("#")]),v._v(" 如何保证消息的顺序性？")]),v._v(" "),t("p",[v._v("拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点。")]),v._v(" "),t("h3",{attrs:{id:"如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？","aria-hidden":"true"}},[v._v("#")]),v._v(" 如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？")]),v._v(" "),t("blockquote",[t("p",[v._v("消费端每次消费之后要写 mysql，结果 mysql 挂了，消费端 hang 那儿了，不动了；或者是消费端出了个什么岔子，导致消费速度极其慢。")])]),v._v(" "),t("ul",[t("li",[v._v("扩容")]),v._v(" "),t("li",[v._v("过期消失：将过期消息查询出来，并传入MQ")]),v._v(" "),t("li")]),v._v(" "),t("h3",{attrs:{id:"发布订阅模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式","aria-hidden":"true"}},[v._v("#")]),v._v(" 发布订阅模式")]),v._v(" "),t("p",[v._v("1、每个消费者监听自己的队列。")]),v._v(" "),t("p",[v._v("2、生产者将消息发给broker，由"),t("strong",[v._v("交换机将消息转发到绑定此交换机的每个队列")]),v._v("，每个绑定交换机的队列都将接收到消息")]),v._v(" "),t("p",[v._v("==案例："),t("strong",[v._v("用户通知")]),v._v("，当用户充值成功或转账完成系统通知用户，通知方式有"),t("strong",[v._v("短信、邮件")]),v._v("多种方法 。==")]),v._v(" "),t("h3",{attrs:{id:"路由模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由模式","aria-hidden":"true"}},[v._v("#")]),v._v(" 路由模式")]),v._v(" "),t("p",[v._v("1、每个消费者监听自己的队列，并且设置routingkey。")]),v._v(" "),t("p",[v._v("2、生产者将消息发给交换机，由"),t("strong",[v._v("交换机根据routingkey来转发消息到指定的队列")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"带通配符的路由模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#带通配符的路由模式","aria-hidden":"true"}},[v._v("#")]),v._v(" 带通配符的路由模式")]),v._v(" "),t("p",[v._v("=="),t("strong",[v._v("根据用户的通知设置去通知用户")]),v._v("，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种通知类型都接收的则两种通知都有效。==")]),v._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("//绑定email通知队列")]),v._v("\nchannel"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("queueBind")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("QUEUE_INFORM_EMAIL"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("EXCHANGE_TOPICS_INFORM"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"inform.#.email.#"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[v._v("//绑定sms通知队列")]),v._v("\nchannel"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[v._v("queueBind")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("QUEUE_INFORM_SMS"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v("EXCHANGE_TOPICS_INFORM"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"inform.#.sms.#"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n")])])]),t("h3",{attrs:{id:"为什么使用消息队列？-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用消息队列？-2","aria-hidden":"true"}},[v._v("#")]),v._v(" 为什么使用消息队列？")]),v._v(" "),t("ul",[t("li",[v._v("解耦：其他系统都要这个数据，只需要订阅这个队列即可，不和本系统直接打交道")]),v._v(" "),t("li",[v._v("异步：对于写操作来说，不需要获取结果，可以采用异步方式")]),v._v(" "),t("li",[v._v("削峰：存放在MQ中，慢慢消费，无论有多少请求进入MQ")])]),v._v(" "),t("h3",{attrs:{id:"如何保证消息队列的高可用？-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保证消息队列的高可用？-2","aria-hidden":"true"}},[v._v("#")]),v._v(" 如何保证消息队列的高可用？")]),v._v(" "),t("p",[t("strong",[v._v("镜像集群模式")]),v._v("：创建的 queue，无论元数据还是 queue 里的消息都会"),t("strong",[v._v("存在于多个实例上")]),v._v("，每次你写消息到 queue 的时候，都会自动把"),t("strong",[v._v("消息同步")]),v._v("到多个实例的 queue 上。")]),v._v(" "),t("h3",{attrs:{id:"rabbitmq如何保证可靠性传输？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq如何保证可靠性传输？","aria-hidden":"true"}},[v._v("#")]),v._v(" RabbitMQ如何保证可靠性传输？")]),v._v(" "),t("p",[v._v("持久化：持久化交换机、队列、消息")]),v._v(" "),t("p",[v._v("ACK确认机制：")]),v._v(" "),t("ul",[t("li",[v._v("消息发送确认：\n"),t("ul",[t("li",[t("strong",[v._v("ConfirmCallback消息正确到达 Exchange 中时回调")]),v._v("（有个消息唯一标示来确定哪条消息）")]),v._v(" "),t("li",[t("strong",[v._v("ReturnCallback消息没有正确到达QUEUE时")]),v._v("触发回调，如果正确到达队列不执行")])])]),v._v(" "),t("li",[v._v("手动消息接收确认（根据是否包含error来确认或拒绝）")])]),v._v(" "),t("p",[v._v("消息发送、消息接收时"),t("strong",[v._v("记录日志，定时轮询")]),v._v("，没发送的继续发送。")]),v._v(" "),t("h2",{attrs:{id:"springtask-cron表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springtask-cron表达式","aria-hidden":"true"}},[v._v("#")]),v._v(" SpringTask-Cron表达式")]),v._v(" "),t("p",[v._v("Seconds Minutes Hours DayofMonth Month DayofWeek Year（只能省略最后一位，且俩最长的不能同时出现，其中一个必为?）")]),v._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[v._v("@Scheduled")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("cron "),t("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[v._v('"0 * * * * ?"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n")])])]),t("p",[v._v('0 0 10,14,16 * * ? 每天上午10点，下午2点，4点\n0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时\n0 0 12 ? * WED 表示每个星期三中午12点\n"0 0 12 * * ?" 每天中午12点触发\n"0 15 10 ? * *" 每天上午10:15触发\n"0 15 10 * * ?" 每天上午10:15触发\n"0 15 10 * * ? *" 每天上午10:15触发\n"0 15 10 * * ? 2005" 2005年的每天上午10:15触发\n"0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发\n"0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发\n"0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发\n"0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发\n"0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发\n"0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发\n"0 15 10 15 * ?" 每月15日上午10:15触发\n"0 15 10 L * ?" 每月最后一日的上午10:15触发\n"0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发\n"0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发\n"0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发')]),v._v(" "),t("h2",{attrs:{id:"spring-cloud"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud","aria-hidden":"true"}},[v._v("#")]),v._v(" Spring Cloud")]),v._v(" "),t("h3",{attrs:{id:"springcloud如何实现服务注册发现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springcloud如何实现服务注册发现","aria-hidden":"true"}},[v._v("#")]),v._v(" springcloud如何实现服务注册发现")]),v._v(" "),t("p",[v._v("服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper），@EnableDisscoveryClient会被带@EnableEurekaServer的Eureka服务发现并注册。")])])},[],!1,null,null,null);_.default=a.exports}}]);