(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{142:function(e,s,t){"use strict";t.r(s);var r=t(0),v=Object(r.a)({},function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"nosql"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nosql","aria-hidden":"true"}},[e._v("#")]),e._v(" NoSQL")]),e._v(" "),t("h2",{attrs:{id:"redis-6379"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-6379","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis-6379")]),e._v(" "),t("h3",{attrs:{id:"什么是redis？用处？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是redis？用处？","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是Redis？用处？")]),e._v(" "),t("p",[e._v("Redis是一个开源"),t("strong",[e._v("的高性能key-value数据库")]),e._v("。直接从内存中读取数据，"),t("strong",[e._v("减少数据库访问压力")]),e._v("，"),t("strong",[e._v("承受并发能力强")]),e._v("；应用场景如下：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("缓存")]),e._v("（首页缓存、数据查询等）")]),e._v(" "),t("li",[t("strong",[e._v("消息中间件")])]),e._v(" "),t("li",[e._v("计数器/"),t("strong",[e._v("排行榜")])])]),e._v(" "),t("h3",{attrs:{id:"redis和-memcached-的区别？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis和-memcached-的区别？","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis和 memcached 的区别？")]),e._v(" "),t("ul",[t("li",[e._v("Redis支持"),t("strong",[e._v("丰富的数据类型")]),e._v("（5个）；memcached仅支持简单的数据类型String")]),e._v(" "),t("li",[e._v("Redis"),t("strong",[e._v("支持数据持久化")]),e._v("，可以将内存中数据保存到磁盘中，重启后再次加载使用；memcached不支持")]),e._v(" "),t("li",[e._v("Redis"),t("strong",[e._v("原生支持集群（cluster）")]),e._v("；memcached没有原生的方式")])]),e._v(" "),t("h3",{attrs:{id:"redis-常见数据结构以及使用场景分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-常见数据结构以及使用场景分析","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis 常见数据结构以及使用场景分析")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("String：可以是String、数字。常规"),t("strong",[e._v("计数")]),e._v("：微博数、粉丝数")]),e._v(" "),t("p",[e._v("set / get / del")])]),e._v(" "),t("li",[t("p",[e._v("Hash：适合存储"),t("strong",[e._v("对象")]),e._v("数据：购物车、商品")]),e._v(" "),t("p",[e._v("hset / hget / hgetall / hdel")])]),e._v(" "),t("li",[t("p",[e._v("List：内部是链表："),t("strong",[e._v("消息列表（高性能分页，下拉不断分页）")]),e._v("、关注列表、粉丝列表")]),e._v(" "),t("p",[e._v("l/rpush / lrange / l/rpop")])]),e._v(" "),t("li",[t("p",[e._v("Set：与List类似，去重。基于 set 轻易实现"),t("strong",[e._v("交集、并集、差集")]),e._v("的操作。如"),t("strong",[e._v("共同关注")]),e._v("、共同粉丝")]),e._v(" "),t("p",[t("code",[e._v("sinterstore key1 key2 key3")]),e._v("将交集存在key1内")]),e._v(" "),t("p",[e._v("sadd / smembers / srem")])]),e._v(" "),t("li",[t("p",[e._v("ZSet：相比Set多个"),t("strong",[e._v("score权重")]),e._v("，按score排序。直播中"),t("strong",[e._v("礼物排行榜、在线用户列表")])]),e._v(" "),t("p",[e._v("zadd / zrange / zrem")])])]),e._v(" "),t("h3",{attrs:{id:"redis-设置过期时间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-设置过期时间","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis 设置过期时间")]),e._v(" "),t("blockquote",[t("p",[e._v("expire  /ɪkˈspaɪr/ 到期，期满；结束")])]),e._v(" "),t("p",[e._v("set key 的时候，都可以给一个 "),t("strong",[e._v("expire time")]),e._v("，就是过期时间。时间到后删除方式如下：")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("定期删除")]),e._v("：redis默认是"),t("strong",[e._v("每隔 100ms 就随机抽取")]),e._v("一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！")]),e._v(" "),t("li",[t("strong",[e._v("惰性删除")]),e._v("：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉，这就是所谓的惰性删除")])]),e._v(" "),t("h3",{attrs:{id:"redis-内存淘汰机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-内存淘汰机制","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis 内存淘汰机制")]),e._v(" "),t("p",[e._v("但是若有的key没有被定期删除，也没有执行惰性删除。此时需要用到 Redis 内存淘汰机制")]),e._v(" "),t("blockquote",[t("p",[e._v("MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是"),t("strong",[e._v("热点数据")]),e._v("？")])]),e._v(" "),t("p",[e._v("redis 提供 6 种数据淘汰策略：")]),e._v(" "),t("ul",[t("li",[e._v("volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选"),t("strong",[e._v("最近最少使用")]),e._v("的数据淘汰")]),e._v(" "),t("li",[e._v("volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选"),t("strong",[e._v("将要过期")]),e._v("的数据淘汰")]),e._v(" "),t("li",[e._v("volatile-random：从已设置过期时间的数据集（server.db[i].expires）中"),t("strong",[e._v("任意选择")]),e._v("数据淘汰")]),e._v(" "),t("li",[e._v("allkeys-lru：当"),t("strong",[e._v("内存不足以容纳新写入数据时")]),e._v("，在键空间中，"),t("strong",[e._v("移除最近最少使用的key")]),e._v("（这个是最常用的）.")]),e._v(" "),t("li",[e._v("allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰")]),e._v(" "),t("li",[e._v("no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！")])]),e._v(" "),t("h3",{attrs:{id:"redis-持久化机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化机制","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis 持久化机制")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("RDB")]),e._v("（快照，snapshotting）："),t("strong",[e._v("默认")]),e._v("方式，不需要进行配置。"),t("strong",[e._v("在一定的间隔时间中，检测key的变化情况")]),e._v("，然后持久化数据")]),e._v(" "),t("div",{staticClass:"language-nginx extra-class"},[t("pre",{pre:!0,attrs:{class:"language-nginx"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   after 900 sec (15 min) if at least 1 key changed")]),e._v("\nsave "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("900")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   after 300 sec (5 min) if at least 10 keys changed")]),e._v("\nsave "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("300")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   after 60 sec if at least 10000 keys changed")]),e._v("\nsave "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("60")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("10000")]),e._v("\n")])])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("AOF")]),e._v("（append-only ﬁle，只追加文件）：日志记录方式，可以每一次命令操作后，持久化数据。编辑redis.windwos.conf文件")]),e._v(" "),t("div",{staticClass:"language-nginx extra-class"},[t("pre",{pre:!0,attrs:{class:"language-nginx"}},[t("code",[e._v("appendonly no（关闭aof） "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("--")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" appendonly yes （开启aof）\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# appendfsync always ： 每一次操作都进行持久化")]),e._v("\nappendfsync everysec ： 每隔一秒进行一次持久化\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# appendfsync no\t ： 不进行持久化")]),e._v("\n")])])])])]),e._v(" "),t("h3",{attrs:{id:"缓存雪崩和缓存穿透问题解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩和缓存穿透问题解决方案","aria-hidden":"true"}},[e._v("#")]),e._v(" 缓存雪崩和缓存穿透问题解决方案")]),e._v(" "),t("ul",[t("li",[e._v("缓存雪崩：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。\n"),t("ul",[t("li",[e._v("事前：尽量保证整个 "),t("strong",[e._v("redis 集群的高可用性")]),e._v("，发现机器宕机尽快补上。选择合适的"),t("strong",[e._v("内存淘汰策略")]),e._v("。")]),e._v(" "),t("li",[e._v("事中：本地 ehcache缓存 + hystrix限流&降级，避免MySQL崩掉")]),e._v(" "),t("li",[e._v("事后：利用 redis 持久化机制保存的数据尽快恢复缓存")])])])]),e._v(" "),t("h3",{attrs:{id:"redis-cluster"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-cluster","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis-Cluster")]),e._v(" "),t("p",[e._v("Redis-Cluster采用"),t("strong",[e._v("无中心结构")]),e._v("，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("分布存储机制-槽")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("redis-cluster 把所有的物理节点映射到[0-16383]slot（槽） 上，cluster 负责维护")])]),e._v(" "),t("li",[t("p",[e._v("Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。")]),e._v(" "),t("p",[e._v("例如三个节点：槽分布的值如下：SERVER1:  0-5460；SERVER2:  5461-10922；SERVER3:  10923-16383")])])])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("容错机制-投票")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("选举过程是集群中所有master参与,如果半数以上master节点与故障节点通信超过(cluster-node-timeout)，认为该节点故障，自动触发故障转移操作，采用"),t("strong",[e._v("投票机制")]),e._v("故障节点对应的从节点自动升级为主节点")])]),e._v(" "),t("li",[t("p",[e._v("什么时候整个集群不可用(cluster_state:fail)?")]),e._v(" "),t("p",[e._v("如果集群任意master挂掉，且当前master没有slave，集群进入fail状态，也可以理解成集群的slot映射[0-16383]不完成时进入fail状态.。")])])])])]),e._v(" "),t("h3",{attrs:{id:"redis-为什么是单线程的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-为什么是单线程的","aria-hidden":"true"}},[e._v("#")]),e._v(" Redis 为什么是单线程的")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("因为"),t("strong",[e._v("CPU")]),e._v("不是Redis的瓶颈，"),t("strong",[e._v("瓶颈可能是内存或网络带宽")]),e._v("！")])]),e._v(" "),t("li",[t("p",[e._v("异步非阻塞 IO，避免线程切换及锁的资源损耗")])])])])},[],!1,null,null,null);s.default=v.exports}}]);